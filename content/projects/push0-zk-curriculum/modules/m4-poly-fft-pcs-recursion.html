<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>M4 - Polynomial/FFT/PCS/Recursion</title><style>body{font-family:IBM Plex Sans,Segoe UI,sans-serif;background:#f5f7fb;color:#111827;margin:0}.w{max-width:980px;margin:0 auto;padding:24px}.c{background:#fff;border:1px solid #d6dcea;border-radius:10px;padding:14px;margin-top:10px}h2{margin-top:20px}a{color:#0b4f89}</style></head><body><div class="w"><h1>M4: Polynomial Commitments, FFT, and Recursion</h1><div class="c"><strong>Why this module exists:</strong> push0 discusses multi-stage workflows and aggregation barriers. Those are consequences of proof composition mechanics.</div><div class="c"><h2>Topics (DFS expanded)</h2><ul><li><strong>Arithmetization:</strong> convert computation into polynomial constraints.</li><li><strong>Commitment layer:</strong> commit to large algebraic objects succinctly.</li><li><strong>FFT/MSM hotspots:</strong> why prover runtime is dominated by specific kernels.</li><li><strong>Recursion/aggregation:</strong> prove proofs; introduces barrier synchronization points.</li></ul></div><div class="c"><h2>What to be able to do</h2><ul><li>Draw a proving DAG with barriers introduced by aggregation.</li><li>Explain why barrier locality matters for scheduler partitioning.</li><li>Interpret how proving kernels affect tail behavior.</li></ul></div><div class="c"><h2>Resources</h2><ul><li><a href="https://eprint.iacr.org/2019/953.pdf" target="_blank" rel="noopener">PLONK (commitment and arithmetization references)</a></li><li><a href="https://eprint.iacr.org/2018/046.pdf" target="_blank" rel="noopener">STARK (FRI and transparent commitments)</a></li><li><a href="https://rareskills.io/tutorials/zk-book" target="_blank" rel="noopener">RareSkills ZK Book modules on commitments/recursion</a></li></ul></div><div class="c"><a href="../dfs-master-curriculum.html">Back to master</a></div></div></body></html>
