<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>M0 - Dependency Graph Method</title><style>body{font-family:IBM Plex Sans,Segoe UI,sans-serif;background:#f5f7fb;color:#111827;margin:0}.w{max-width:980px;margin:0 auto;padding:24px}h1,h2,h3{line-height:1.25}h1{font-size:1.8rem}h2{margin-top:22px}.c{background:#fff;border:1px solid #d6dcea;border-radius:10px;padding:14px;margin-top:10px}table{width:100%;border-collapse:collapse}th,td{border:1px solid #d6dcea;padding:8px;vertical-align:top;text-align:left}th{background:#eef2ff}code{background:#eef2ff;border:1px solid #dbe4ff;border-radius:4px;padding:1px 5px}a{color:#0b4f89}</style></head><body><div class="w"><h1>M0: Dependency Graph + DFS/BFS Method</h1><div class="c"><p><strong>Why:</strong> You asked for a repeatable method to create first-principles curricula for any deep topic. This module defines that method.</p></div><div class="c"><h2>Target node</h2><p><code>T0 = Understand push0 claims, limits, and implementation tradeoffs for real-time proving.</code></p><p>Immediate prerequisites: <code>ZK proof systems</code>, <code>Ethereum timing/execution</code>, <code>distributed orchestration</code>, <code>performance/reliability metrics</code>.</p></div><div class="c"><h2>DFS expansion rules</h2><table><thead><tr><th>Rule</th><th>Definition</th></tr></thead><tbody><tr><td>R1: recurse</td><td>If understanding of node N requires concept P not yet known, add edge N -> P.</td></tr><tr><td>R2: stop condition</td><td>Stop if P is generally high-school baseline (algebra, basic probability, functions, reading charts).</td></tr><tr><td>R3: mark state</td><td>Label each node as <code>teach</code>, <code>refresh</code>, or <code>assumed</code>.</td></tr><tr><td>R4: output</td><td>Each non-assumed node gets learning goals, exercises, and primary resources.</td></tr></tbody></table></div><div class="c"><h2>Graph for this curriculum</h2><p><strong>T0</strong> -> (A) ZK core -> (A1) interactive proofs -> (A2) commitments/polynomials -> (A3) SNARK/STARK/recursion</p><p><strong>T0</strong> -> (B) Ethereum context -> (B1) EVM state transition -> (B2) slots/finality -> (B3) rollup proof submission semantics</p><p><strong>T0</strong> -> (C) orchestration -> (C1) queue semantics -> (C2) retries/idempotency -> (C3) barrier sync and tail-latency</p><p><strong>T0</strong> -> (D) evaluation -> (D1) P50/P95/P99 -> (D2) scaling efficiency -> (D3) failure-injection interpretation</p></div><div class="c"><h2>High-school cutoff list (assumed)</h2><ul><li>Linear equations and basic algebraic manipulation</li><li>Basic probability (independent events, expected value intuition)</li><li>Functions, graphs, and logarithmic growth intuition</li><li>Basic computer science vocabulary (program, input, output, runtime)</li></ul></div><div class="c"><h2>Exercise</h2><p>Take any new paper claim and run the same procedure: write target node, expand unknown prerequisites, stop at high-school cutoff, output module list.</p></div><div class="c"><p><a href="../dfs-master-curriculum.html">Back to master</a></p></div></div></body></html>
