<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MegaETH SALT - Visual Explainer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --font-head: 'Fraunces', Georgia, serif;
    --font-mono: 'IBM Plex Mono', 'SF Mono', Consolas, monospace;

    --bg: #fcfaf4;
    --surface: #fffdf8;
    --surface2: #f5efe2;
    --border: rgba(68, 54, 30, 0.18);
    --text: #2e2618;
    --text-dim: #685a44;

    --accent: #176b87;
    --accent-dim: rgba(23, 107, 135, 0.12);
    --focus: #a14a2f;
    --focus-dim: rgba(161, 74, 47, 0.12);
    --ok: #2f7d4f;
    --ok-dim: rgba(47, 125, 79, 0.12);
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #1c1711;
      --surface: #241f18;
      --surface2: #2d261e;
      --border: rgba(224, 205, 167, 0.2);
      --text: #f0e4cc;
      --text-dim: #ccb98f;

      --accent: #7bd2f0;
      --accent-dim: rgba(123, 210, 240, 0.15);
      --focus: #f19b80;
      --focus-dim: rgba(241, 155, 128, 0.15);
      --ok: #78d39f;
      --ok-dim: rgba(120, 211, 159, 0.16);
    }
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { scroll-behavior: smooth; }

  body {
    font-family: var(--font-head);
    color: var(--text);
    line-height: 1.5;
    padding: 34px;
    background:
      radial-gradient(circle at 10% 0%, rgba(161, 74, 47, 0.08), transparent 26%),
      radial-gradient(circle at 90% 12%, rgba(23, 107, 135, 0.08), transparent 30%),
      var(--bg);
  }

  .wrap {
    max-width: 1360px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 190px 1fr;
    gap: 0 34px;
  }

  .main { min-width: 0; }

  .toc {
    position: sticky;
    top: 22px;
    align-self: start;
    padding: 12px 0;
    max-height: calc(100dvh - 44px);
    overflow-y: auto;
  }

  .toc-title {
    font-family: var(--font-mono);
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-dim);
    padding-bottom: 10px;
    margin-bottom: 8px;
    border-bottom: 1px solid var(--border);
  }

  .toc a {
    display: block;
    text-decoration: none;
    color: var(--text-dim);
    font-family: var(--font-mono);
    font-size: 11px;
    padding: 6px 8px;
    border-radius: 6px;
    border-left: 2px solid transparent;
    transition: 140ms ease;
    margin-bottom: 2px;
  }

  .toc a:hover { background: var(--surface2); color: var(--text); }
  .toc a.active { border-left-color: var(--accent); color: var(--text); background: var(--accent-dim); }

  .hero {
    background: linear-gradient(155deg, var(--surface), var(--surface2));
    border: 1px solid var(--border);
    border-radius: 18px;
    padding: 26px 24px;
    margin-bottom: 18px;
  }

  h1 {
    font-size: clamp(32px, 4.8vw, 54px);
    line-height: 1.04;
    letter-spacing: -0.7px;
    margin-bottom: 8px;
    text-wrap: balance;
  }

  .subtitle {
    font-family: var(--font-mono);
    color: var(--text-dim);
    font-size: 12px;
  }

  .hero-claim {
    margin-top: 14px;
    padding: 12px;
    border-left: 3px solid var(--focus);
    background: var(--focus-dim);
    font-size: 17px;
    text-wrap: balance;
  }

  .sec-head {
    margin: 24px 0 10px;
    font-size: 20px;
    letter-spacing: -0.3px;
    display: flex;
    align-items: center;
    gap: 10px;
    scroll-margin-top: 72px;
  }

  .tag {
    font-family: var(--font-mono);
    font-size: 10px;
    color: var(--accent);
    background: var(--accent-dim);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 4px 8px;
  }

  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 16px;
    margin-bottom: 12px;
    min-width: 0;
  }

  .bullets {
    display: grid;
    gap: 8px;
    padding-left: 20px;
  }

  .bullets li { color: var(--text-dim); overflow-wrap: break-word; }
  .bullets strong { color: var(--text); }

  .mermaid-wrap {
    position: relative;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 34px 16px 16px;
    overflow: auto;
    min-width: 0;
    margin-bottom: 12px;
  }

  .mermaid-wrap .mermaid {
    display: flex;
    justify-content: center;
    transition: transform 0.16s ease;
    transform-origin: top center;
  }

  .zoom-controls {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 3px;
    z-index: 10;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 7px;
    padding: 2px;
  }

  .zoom-controls button {
    width: 28px;
    height: 28px;
    border: 0;
    border-radius: 5px;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: 14px;
  }

  .zoom-controls button:hover { background: var(--surface2); color: var(--text); }
  .mermaid-wrap.is-zoomed { cursor: grab; }
  .mermaid-wrap.is-panning { cursor: grabbing; user-select: none; }

  .mermaid .nodeLabel { font-family: var(--font-head) !important; font-size: 14px !important; }
  .mermaid .edgeLabel { font-family: var(--font-mono) !important; font-size: 11px !important; }

  .table-wrap { overflow-x: auto; min-width: 0; }

  table {
    width: 100%;
    border-collapse: collapse;
    min-width: 780px;
    font-size: 13px;
  }

  th, td {
    border: 1px solid var(--border);
    padding: 10px 11px;
    text-align: left;
    vertical-align: top;
    overflow-wrap: break-word;
  }

  th {
    background: var(--surface2);
    font-family: var(--font-mono);
    font-size: 11px;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--text-dim);
  }

  tr:nth-child(even) td { background: rgba(23, 107, 135, 0.05); }

  .note {
    margin-top: 10px;
    font-family: var(--font-mono);
    font-size: 12px;
    color: var(--text-dim);
  }

  .chip-row {
    margin-top: 10px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .chip {
    font-family: var(--font-mono);
    font-size: 11px;
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 6px 9px;
    background: var(--surface2);
    color: var(--text-dim);
  }

  .chip.ok { background: var(--ok-dim); color: var(--ok); }
  .chip.focus { background: var(--focus-dim); color: var(--focus); }

  @media (max-width: 1040px) {
    body { padding: 0; }
    .wrap { grid-template-columns: 1fr; gap: 0; }

    .toc {
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      gap: 5px;
      align-items: center;
      overflow-x: auto;
      white-space: nowrap;
      max-height: none;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      padding: 10px 14px;
    }

    .toc-title { display: none; }

    .toc a {
      border-left: none;
      border-bottom: 2px solid transparent;
      margin-bottom: 0;
      padding: 6px 9px;
      font-size: 10px;
    }

    .toc a.active { border-left: none; border-bottom-color: var(--accent); }

    .main { padding: 14px; }
    .sec-head { scroll-margin-top: 58px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <nav class="toc" id="toc">
    <div class="toc-title">Contents</div>
    <a href="#s1">1. Core Idea</a>
    <a href="#s2">2. Two-Tier Design</a>
    <a href="#s3">3. Update Flow</a>
    <a href="#s4">4. MPT Comparison</a>
    <a href="#s5">5. Madara Implication</a>
  </nav>

  <div class="main">
    <section class="hero">
      <h1>MegaETH SALT</h1>
      <p class="subtitle">A two-tier state commitment model: dense RAM index + flat sparse disk buckets</p>
      <p class="hero-claim">SALT does not optimize sparse MPTs directly. It avoids sparse-trie overhead by splitting authentication and sparse storage into different tiers.</p>
    </section>

    <h2 id="s1" class="sec-head"><span class="tag">Section 1</span>Core idea in one view</h2>
    <div class="card">
      <ul class="bullets">
        <li><strong>Top tier:</strong> a compact authenticated structure that stays in memory and tracks the high-level commitment frontier.</li>
        <li><strong>Bottom tier:</strong> sparse data stored as flat bucket lists on disk for predictable update I/O.</li>
        <li><strong>Key outcome:</strong> avoid generating and touching large numbers of sparse intermediate trie nodes for each update.</li>
      </ul>
      <div class="chip-row">
        <span class="chip ok">Fast proof-oriented top tier</span>
        <span class="chip focus">Sparse-optimized bottom tier</span>
        <span class="chip">Decoupled responsibilities</span>
      </div>
    </div>

    <h2 id="s2" class="sec-head"><span class="tag">Section 2</span>Two-tier SALT structure</h2>
    <div class="mermaid-wrap">
      <div class="zoom-controls">
        <button onclick="zoomDiagram(this,1.2)">+</button>
        <button onclick="zoomDiagram(this,0.8)">&minus;</button>
        <button onclick="resetZoom(this)">&#8634;</button>
      </div>
      <pre class="mermaid">
flowchart TB
    subgraph T1[Top Tier - In Memory]
      A[Dense authenticated index]
      B[All active children used\nminimal empty-slot waste]
      C[Fast proof/commit frontier]
      A --> B --> C
    end

    subgraph T2[Bottom Tier - On Disk]
      D[Bucket 00xx]
      E[Bucket 01xx]
      F[Bucket 10xx]
      G[Flat key suffix lists]
      D --> G
      E --> G
      F --> G
    end

    C -->|points to bucket digests| T2
      </pre>
    </div>

    <h2 id="s3" class="sec-head"><span class="tag">Section 3</span>Update flow intuition</h2>
    <div class="mermaid-wrap">
      <div class="zoom-controls">
        <button onclick="zoomDiagram(this,1.2)">+</button>
        <button onclick="zoomDiagram(this,0.8)">&minus;</button>
        <button onclick="resetZoom(this)">&#8634;</button>
      </div>
      <pre class="mermaid">
sequenceDiagram
    participant Client as State Update
    participant Index as RAM Top Tier
    participant Bucket as Disk Bucket
    participant Commit as Root Builder

    Client->>Index: Resolve key prefix -> bucket id
    Index->>Bucket: Update one target bucket segment
    Bucket-->>Index: New bucket digest
    Index->>Commit: Update top-tier commitment path
    Commit-->>Client: New global commitment
      </pre>
    </div>
    <div class="card">
      <p class="note">Operational interpretation: one sparse update should mostly hit one bucket path and one upper-index commitment path, not many sparse-trie internal nodes.</p>
    </div>

    <h2 id="s4" class="sec-head"><span class="tag">Section 4</span>SALT vs traditional sparse MPT</h2>
    <div class="card table-wrap">
      <table>
        <thead>
          <tr>
            <th>Dimension</th>
            <th>Traditional Sparse MPT</th>
            <th>SALT-style Two-Tier</th>
            <th>Practical Impact</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Structure objective</td>
            <td>Single unified authenticated trie over all keys</td>
            <td>Split: authenticated RAM index + sparse disk buckets</td>
            <td>Responsibilities are separated by data density</td>
          </tr>
          <tr>
            <td>Sparse handling</td>
            <td>Sparsity induces many mostly-empty intermediate paths</td>
            <td>Sparse keys flattened in bucket lists</td>
            <td>Lower sparse-node churn</td>
          </tr>
          <tr>
            <td>I/O pattern</td>
            <td>Multiple random accesses along trie paths</td>
            <td>Mostly bucket-local update plus upper-tier digest update</td>
            <td>More predictable storage latency</td>
          </tr>
          <tr>
            <td>Hot memory usage</td>
            <td>Depends on cache hit quality across sparse paths</td>
            <td>Top-tier is intentionally RAM-resident</td>
            <td>Faster commitment-path operations</td>
          </tr>
          <tr>
            <td>Migration risk</td>
            <td>Protocol-compatible by definition</td>
            <td>May require protocol-specific commitment compatibility layer</td>
            <td>Compatibility plan is critical</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2 id="s5" class="sec-head"><span class="tag">Section 5</span>What this means for Madara</h2>
    <div class="card">
      <ul class="bullets">
        <li><strong>Near term:</strong> use SALT principles as a performance engine under canonical Bonsai root generation.</li>
        <li><strong>Middle term:</strong> run dual-commit shadow mode to prove deterministic parity on long replays.</li>
        <li><strong>Long term:</strong> only consider native commitment migration if Starknet protocol/spec supports it.</li>
      </ul>
      <div class="chip-row">
        <span class="chip ok">Compatibility-first adoption</span>
        <span class="chip">Benchmark-gated rollout</span>
        <span class="chip focus">Protocol-change deferred</span>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk/dist/mermaid-layout-elk.esm.min.mjs';

  const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  mermaid.registerLayoutLoaders(elkLayouts);
  mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    look: 'handDrawn',
    layout: 'elk',
    themeVariables: {
      primaryColor: isDark ? '#2d261e' : '#f5efe2',
      primaryBorderColor: isDark ? '#7bd2f0' : '#176b87',
      primaryTextColor: isDark ? '#f0e4cc' : '#2e2618',
      secondaryColor: isDark ? '#33231e' : '#f8e9e2',
      secondaryBorderColor: isDark ? '#f19b80' : '#a14a2f',
      secondaryTextColor: isDark ? '#f0e4cc' : '#2e2618',
      tertiaryColor: isDark ? '#253226' : '#eaf7ef',
      tertiaryBorderColor: isDark ? '#78d39f' : '#2f7d4f',
      tertiaryTextColor: isDark ? '#f0e4cc' : '#2e2618',
      lineColor: isDark ? '#ccb98f' : '#685a44',
      fontSize: '14px',
      fontFamily: "'Fraunces', Georgia, serif"
    }
  });
</script>
<script>
  function updateZoomState(wrap) {
    const target = wrap.querySelector('.mermaid');
    const zoom = parseFloat(target.dataset.zoom || '1');
    wrap.classList.toggle('is-zoomed', zoom > 1);
  }

  function zoomDiagram(btn, factor) {
    const wrap = btn.closest('.mermaid-wrap');
    const target = wrap.querySelector('.mermaid');
    const current = parseFloat(target.dataset.zoom || '1');
    const next = Math.min(Math.max(current * factor, 0.3), 5);
    target.dataset.zoom = String(next);
    target.style.transform = 'scale(' + next + ')';
    updateZoomState(wrap);
  }

  function resetZoom(btn) {
    const wrap = btn.closest('.mermaid-wrap');
    const target = wrap.querySelector('.mermaid');
    target.dataset.zoom = '1';
    target.style.transform = 'scale(1)';
    updateZoomState(wrap);
  }

  document.querySelectorAll('.mermaid-wrap').forEach((wrap) => {
    wrap.addEventListener('wheel', (e) => {
      if (!e.ctrlKey && !e.metaKey) return;
      e.preventDefault();
      const target = wrap.querySelector('.mermaid');
      const current = parseFloat(target.dataset.zoom || '1');
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      const next = Math.min(Math.max(current * factor, 0.3), 5);
      target.dataset.zoom = String(next);
      target.style.transform = 'scale(' + next + ')';
      updateZoomState(wrap);
    }, { passive: false });

    let startX = 0;
    let startY = 0;
    let scrollL = 0;
    let scrollT = 0;

    wrap.addEventListener('mousedown', (e) => {
      if (e.target.closest('.zoom-controls')) return;
      const target = wrap.querySelector('.mermaid');
      if (parseFloat(target.dataset.zoom || '1') <= 1) return;
      wrap.classList.add('is-panning');
      startX = e.clientX;
      startY = e.clientY;
      scrollL = wrap.scrollLeft;
      scrollT = wrap.scrollTop;
    });

    window.addEventListener('mousemove', (e) => {
      if (!wrap.classList.contains('is-panning')) return;
      wrap.scrollLeft = scrollL - (e.clientX - startX);
      wrap.scrollTop = scrollT - (e.clientY - startY);
    });

    window.addEventListener('mouseup', () => {
      wrap.classList.remove('is-panning');
    });
  });

  (function() {
    const toc = document.getElementById('toc');
    const links = toc.querySelectorAll('a');
    const sections = [];

    links.forEach((link) => {
      const id = link.getAttribute('href').slice(1);
      const el = document.getElementById(id);
      if (el) sections.push({ id, el, link });
    });

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        links.forEach((l) => l.classList.remove('active'));
        const match = sections.find((s) => s.el === entry.target);
        if (!match) return;
        match.link.classList.add('active');
        if (window.innerWidth <= 1040) {
          match.link.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      });
    }, { rootMargin: '-10% 0px -80% 0px' });

    sections.forEach((s) => observer.observe(s.el));

    links.forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const id = link.getAttribute('href').slice(1);
        const el = document.getElementById(id);
        if (!el) return;
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        history.replaceState(null, '', '#' + id);
      });
    });
  })();
</script>
</body>
</html>
