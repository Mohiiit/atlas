<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rust Evaluator + GEPA Optimization Loop</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --font-body: 'Manrope', system-ui, sans-serif;
    --font-mono: 'Fira Code', ui-monospace, SFMono-Regular, Menlo, monospace;
    --bg: #fff8ed;
    --surface: #fffdf9;
    --surface-2: #fff4de;
    --border: rgba(88, 51, 13, 0.16);
    --border-strong: rgba(88, 51, 13, 0.30);
    --text: #2e1b08;
    --text-dim: #7b5732;
    --accent: #c97a0d;
    --good: #2a9d8f;
    --warn: #c94f1d;
    --accent-dim: rgba(201, 122, 13, 0.12);
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #1a1208;
      --surface: #22180d;
      --surface-2: #2e1f10;
      --border: rgba(255, 211, 162, 0.16);
      --border-strong: rgba(255, 211, 162, 0.28);
      --text: #ffe8c8;
      --text-dim: #d7a973;
      --accent: #ffb347;
      --good: #57d6c5;
      --warn: #ff9f80;
      --accent-dim: rgba(255, 179, 71, 0.16);
    }
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: var(--font-body);
    color: var(--text);
    background:
      radial-gradient(circle at 15% -10%, var(--accent-dim), transparent 40%),
      radial-gradient(circle at 95% 0%, color-mix(in srgb, var(--good) 16%, transparent), transparent 32%),
      var(--bg);
    min-height: 100vh;
    padding: 34px;
  }

  .container {
    max-width: 1180px;
    margin: 0 auto;
    display: grid;
    gap: 16px;
  }

  .card {
    background: color-mix(in srgb, var(--surface) 94%, transparent);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 16px;
    min-width: 0;
  }

  h1 {
    font-size: clamp(30px, 3.8vw, 46px);
    letter-spacing: -0.03em;
    margin-bottom: 8px;
  }

  .subtitle {
    font-family: var(--font-mono);
    color: var(--text-dim);
    font-size: 12px;
    margin-bottom: 6px;
  }

  .lead {
    color: var(--text-dim);
    line-height: 1.62;
    max-width: 980px;
    margin-bottom: 6px;
  }

  .row {
    display: grid;
    grid-template-columns: 1.3fr 1fr;
    gap: 14px;
    min-width: 0;
  }

  h2 {
    font-size: 19px;
    margin-bottom: 8px;
  }

  p {
    color: var(--text-dim);
    font-size: 14px;
    line-height: 1.62;
    margin-bottom: 12px;
  }

  .mermaid-wrap {
    position: relative;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 34px 14px 14px;
    overflow: auto;
    min-width: 0;
  }

  .mermaid-wrap .mermaid {
    display: flex;
    justify-content: center;
    transform-origin: top center;
    transition: transform 0.2s ease;
  }

  .zoom-controls {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 10;
    display: flex;
    gap: 2px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 2px;
  }

  .zoom-controls button {
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 4px;
    background: transparent;
    color: var(--text-dim);
    font-family: var(--font-mono);
    cursor: pointer;
  }

  .zoom-controls button:hover {
    background: var(--accent-dim);
    color: var(--text);
  }

  .mermaid-wrap.is-zoomed { cursor: grab; }
  .mermaid-wrap.is-panning { cursor: grabbing; user-select: none; }

  .mermaid .nodeLabel {
    font-family: var(--font-body) !important;
    font-size: 15px !important;
  }

  .mermaid .edgeLabel {
    font-family: var(--font-mono) !important;
    font-size: 12px !important;
    color: var(--text-dim) !important;
  }

  .mermaid .edgeLabel rect {
    fill: var(--surface-2) !important;
    stroke: var(--border) !important;
  }

  .mermaid .node rect,
  .mermaid .node circle,
  .mermaid .node polygon,
  .mermaid .node path {
    stroke-width: 1.5px !important;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    font-size: 13px;
  }

  th, td {
    border-bottom: 1px solid var(--border);
    padding: 10px;
    text-align: left;
    vertical-align: top;
  }

  th {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-family: var(--font-mono);
    color: var(--text-dim);
    background: color-mix(in srgb, var(--surface-2) 70%, transparent);
  }

  tr:last-child td { border-bottom: none; }

  .badge {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 999px;
    font-family: var(--font-mono);
    font-size: 11px;
    border: 1px solid var(--border-strong);
    background: var(--surface-2);
  }

  .ok { color: var(--good); }
  .warn { color: var(--warn); }

  .list {
    list-style: none;
    display: grid;
    gap: 8px;
  }

  .list li {
    padding-left: 14px;
    position: relative;
    color: var(--text-dim);
    font-size: 13px;
    line-height: 1.55;
  }

  .list li::before {
    content: "";
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent);
    left: 0;
    top: 8px;
  }

  @media (max-width: 980px) {
    body { padding: 18px; }
    .row { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <main class="container">
    <header class="card">
      <div class="subtitle">YapCode Research Visual • Rust Evaluator Design</div>
      <h1>GEPA Loop for Coding Agents: Rust E2E Evaluator</h1>
      <p class="lead">
        GEPA optimizes whatever the evaluator rewards. For coding, evaluator quality matters more than optimizer choice.
        The loop below shows a robust Rust scoring path and runtime guardrails to keep optimization practical.
      </p>
    </header>

    <section class="card">
      <h2>1) Rust Candidate Evaluation Loop</h2>
      <p>Each candidate prompt produces an agent run. The evaluator returns score + diagnostics (Actionable Side Information) for the next mutation.</p>
      <div class="mermaid-wrap">
        <div class="zoom-controls">
          <button onclick="zoomDiagram(this, 1.2)" title="Zoom in">+</button>
          <button onclick="zoomDiagram(this, 0.8)" title="Zoom out">&minus;</button>
          <button onclick="resetZoom(this)" title="Reset zoom">&#8634;</button>
        </div>
        <pre class="mermaid">
flowchart LR
  P[Candidate Prompt] --> R[Agent Run]
  R --> C{cargo check/build pass?}
  C -->|No| F1[Low Score + Compiler Errors]
  C -->|Yes| T{cargo test pass rate}
  T --> L{clippy and fmt quality}
  L --> B{benchmark delta needed?}
  B --> S[Composite Score]
  F1 --> M[GEPA Reflective Mutation]
  S --> M
  M --> P

  S -. side info .-> SI[ASI: failing tests, traces, latency, token usage]
  SI -. guides .-> M

  classDef gate fill:#fff0df,stroke:#c97a0d,color:#3f2508
  classDef fail fill:#ffe4dc,stroke:#c94f1d,color:#4a1b0f
  classDef good fill:#daf7f3,stroke:#2a9d8f,color:#0d3b35
  classDef core fill:#e8d9c6,stroke:#7b5732,color:#2e1b08

  class C,T,L,B gate
  class F1 fail
  class S,SI good
  class P,R,M core
        </pre>
      </div>
    </section>

    <section class="row">
      <article class="card">
        <h2>2) Suggested Score Components</h2>
        <p>Use hard gates first, then weighted optimization with explicit penalties for tokens and wall-clock runtime.</p>
        <table>
          <thead>
            <tr>
              <th>Component</th>
              <th>Example Weight</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><span class="badge">Compile gate</span></td>
              <td>Required</td>
              <td><span class="warn">Fail => near-zero score</span></td>
            </tr>
            <tr>
              <td><span class="badge">Test pass</span></td>
              <td>0.55</td>
              <td>Main correctness objective</td>
            </tr>
            <tr>
              <td><span class="badge">Compile quality</span></td>
              <td>0.20</td>
              <td>Warning/diagnostic quality beyond binary pass</td>
            </tr>
            <tr>
              <td><span class="badge">Performance</span></td>
              <td>0.15</td>
              <td>Enable only for perf-sensitive tasks</td>
            </tr>
            <tr>
              <td><span class="badge">Style/static quality</span></td>
              <td>0.10</td>
              <td>Clippy deny-list + optional rustfmt check</td>
            </tr>
            <tr>
              <td><span class="badge">Cost penalty</span></td>
              <td>- λ tokens</td>
              <td><span class="ok">Forces quality-per-dollar behavior</span></td>
            </tr>
            <tr>
              <td><span class="badge">Latency penalty</span></td>
              <td>- μ runtime</td>
              <td>Prevents slow but high-scoring regressions</td>
            </tr>
          </tbody>
        </table>
      </article>

      <article class="card">
        <h2>3) Guardrails for Long Jobs</h2>
        <ul class="list">
          <li>Set `max_metric_calls` and `max_candidate_proposals` per run.</li>
          <li>Use timeout/no-improvement stop callbacks.</li>
          <li>Enable evaluation caching to avoid duplicate calls.</li>
          <li>Persist `run_dir` so runs can resume safely.</li>
          <li>Parallelize evaluator jobs with bounded worker count.</li>
          <li>Promote only when holdout score and cost both improve.</li>
        </ul>
      </article>
    </section>
  </main>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk/dist/mermaid-layout-elk.esm.min.mjs';

  const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

  mermaid.registerLayoutLoaders(elkLayouts);
  mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    look: 'handDrawn',
    layout: 'elk',
    flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'linear' },
    themeVariables: {
      background: isDark ? '#2e1f10' : '#fff4de',
      primaryColor: isDark ? '#3a2713' : '#fff0df',
      primaryTextColor: isDark ? '#ffe8c8' : '#2e1b08',
      primaryBorderColor: isDark ? '#ffb347' : '#c97a0d',
      secondaryColor: isDark ? '#19332e' : '#daf7f3',
      secondaryTextColor: isDark ? '#dcfff8' : '#0d3b35',
      secondaryBorderColor: isDark ? '#57d6c5' : '#2a9d8f',
      tertiaryColor: isDark ? '#4f2618' : '#ffe4dc',
      tertiaryTextColor: isDark ? '#ffd9cc' : '#4a1b0f',
      tertiaryBorderColor: isDark ? '#ff9f80' : '#c94f1d',
      lineColor: isDark ? '#d7a973' : '#7b5732',
      edgeLabelBackground: isDark ? '#2e1f10' : '#fff4de',
      fontFamily: 'Manrope, sans-serif',
      fontSize: '16px'
    }
  });
</script>
<script>
function setZoom(wrap, zoom) {
  const target = wrap.querySelector('.mermaid');
  target.style.transform = 'scale(' + zoom + ')';
  target.dataset.zoom = String(zoom);
  wrap.classList.toggle('is-zoomed', zoom > 1);
}

function zoomDiagram(btn, factor) {
  const wrap = btn.closest('.mermaid-wrap');
  const target = wrap.querySelector('.mermaid');
  const current = parseFloat(target.dataset.zoom || '1');
  const next = Math.min(5, Math.max(0.3, current * factor));
  setZoom(wrap, next);
}

function resetZoom(btn) {
  const wrap = btn.closest('.mermaid-wrap');
  setZoom(wrap, 1);
  wrap.scrollLeft = 0;
  wrap.scrollTop = 0;
}

document.querySelectorAll('.mermaid-wrap').forEach((wrap) => {
  const target = wrap.querySelector('.mermaid');

  wrap.addEventListener('wheel', (e) => {
    if (!(e.ctrlKey || e.metaKey)) return;
    e.preventDefault();
    const current = parseFloat(target.dataset.zoom || '1');
    const factor = e.deltaY > 0 ? 0.92 : 1.08;
    const next = Math.min(5, Math.max(0.3, current * factor));
    setZoom(wrap, next);
  }, { passive: false });

  let isDown = false;
  let sx = 0;
  let sy = 0;
  let sl = 0;
  let st = 0;

  wrap.addEventListener('mousedown', (e) => {
    if (e.target.closest('.zoom-controls')) return;
    if (parseFloat(target.dataset.zoom || '1') <= 1) return;
    isDown = true;
    wrap.classList.add('is-panning');
    sx = e.clientX;
    sy = e.clientY;
    sl = wrap.scrollLeft;
    st = wrap.scrollTop;
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    wrap.scrollLeft = sl - (e.clientX - sx);
    wrap.scrollTop = st - (e.clientY - sy);
  });

  window.addEventListener('mouseup', () => {
    isDown = false;
    wrap.classList.remove('is-panning');
  });
});
</script>
</body>
</html>
